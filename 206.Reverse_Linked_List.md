1st.
stackにnodeをひとつづつ積んでいってすべて積み終わった後それを取り出せばいけると方針はすぐ立ったので実装にかかった。
順番に取り出して行くときに始まりがないといけないので一つだけ取り出したがこれが良かった科は分からない。
もっとシンプル実装があったかも。
dummy_nodeもresultの前にしたかったのでListNode(-1, result)としたがこれも読む人にとっては読みづらくなる原因かも。

```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        stack = deque()
    
        while node:
            stack.append(node)
            node = node.next
        
        if not stack:
            return None
        
        result = stack.pop()
        dummy_node = ListNode(-1, result)
        
        while stack:
            result.next = ListNode(stack.pop().val)
            result = result.next
    
        return dummy_node.next
```


2nd.
始めは
```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        stack = deque()
    
        while node:
            stack.append(node)
            node = node.next
        
        dummy_node = ListNode()
        result = dummy_node
        
        while stack:
            result.next = stack.pop()
            result = result.next
    
        return dummy_node.next
```
と書いてMemory Limited Exceededになっていた。これは最後にresultに追加したnodeのnextは変更されておらず一つ前にresultに入ったnodeを指しているのでその二つのnodeがお互いを指すループになっていて抜け出せないということ。
これの解決策としてnode.valだけ受け取って新しくListNodeをつくる方法で解いたが、問題となっているので最後のnodeのnextだけなのでこれをNoneにすればよい。
https://github.com/SanakoMeine/leetcode/pull/8
https://github.com/olsen-blue/Arai60/pull/7/files
```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        stack = deque()
    
        while node:
            stack.append(node)
            node = node.next
        
        dummy_node = ListNode()
        result = dummy_node
        
        while stack:
            result.next = stack.pop()
            result = result.next
        result.next = None
    
        return dummy_node.next
```

また、stackを用いない解法ひとつづつnodeのnextを付け替える方法を実装した。
こちらは空間計算量がO(1)なのでstackを用いた方法(O(n))より効率的
名前に関してはかなり悩んだが、odaさんの話のイメージから
old(順Liked List) →　new(逆Linked list)にけて行くという意味を込めてnew, oldとした
これでどちらのLinkedListについて言っているのか分からなくなることはないと思う
https://discord.com/channels/1084280443945353267/1295357747545505833/1298524551592018003
```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        new_next = None
    
        while node:
            old_next = node.next
            node.next = new_next
            new_next = node
            node = old_next

        return new_next
```

3rd.
二つの方法で繰り返し実装した。
```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        stack = deque()

        while node:
            stack.append(node)
            node = node.next
        
        dummy_node = ListNode()
        result = dummy_node

        while stack:
            result.next = stack.pop()
            result = result.next
        result.next = None
    
        return dummy_node.next
```

```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        new_next = None

        while node:
            old_next = node.next
            node.next = new_next
            new_next = node
            node = old_next
        
        return new_next
```